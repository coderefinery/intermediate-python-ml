# Merging DataFrames in Pandas (15 mins)
## Lecture Materials with Exercises

### Introduction (2 minutes)

**Slide 1: Combining Data in Pandas**
- Real-world analysis often requires combining data from multiple sources
- Pandas provides powerful tools for combining datasets vertically and horizontally
- Two primary approaches: concatenation and joining/merging
- These operations build on database concepts but with Pandas flexibility

**Talking Points:**
- "In real-world data analysis, you rarely have all the data you need in a single file or table."
- "Combining data from multiple sources is a fundamental data wrangling skill."
- "Pandas gives us two main approaches: stacking data (concatenation) and joining data on common keys (merging)."
- "These operations are inspired by SQL database operations but with the added flexibility of Pandas."

---

### 1. Concatenation with pd.concat() (3 minutes)

**Slide 2: Vertical and Horizontal Concatenation**

| Parameter | Purpose | Common Values |
|-----------|---------|---------------|
| `objs` | List of DataFrames to concatenate | `[df1, df2, ...]` |
| `axis` | Direction of concatenation | `0` (vertical, default), `1` (horizontal) |
| `join` | How to handle non-overlapping columns/indices | `'outer'` (keep all, default), `'inner'` (keep only shared) |
| `ignore_index` | Whether to reset the index | `False` (default), `True` (create new sequential index) |
| `keys` | Create hierarchical index | List of keys for each DataFrame |

**Code Example 1: Basic Concatenation**
```python
import pandas as pd
import numpy as np

# Create sample DataFrames
df1 = pd.DataFrame({
    'A': ['A0', 'A1', 'A2'],
    'B': ['B0', 'B1', 'B2']
}, index=['K0', 'K1', 'K2'])

df2 = pd.DataFrame({
    'A': ['A3', 'A4', 'A5'],
    'B': ['B3', 'B4', 'B5']
}, index=['K3', 'K4', 'K5'])

df3 = pd.DataFrame({
    'C': ['C6', 'C7', 'C8'],
    'D': ['D6', 'D7', 'D8']
}, index=['K6', 'K7', 'K8'])

print("df1:")
print(df1)
print("\ndf2:")
print(df2)
print("\ndf3:")
print(df3)

# 1. Basic vertical concatenation (stacking)
result1 = pd.concat([df1, df2])
print("\n1. Vertical concatenation of df1 and df2:")
print(result1)

# 2. Horizontal concatenation (side by side)
result2 = pd.concat([df1, df3], axis=1)
print("\n2. Horizontal concatenation of df1 and df3:")
print(result2)
```

**Code Example 2: Advanced Concatenation Options**
```python
# 3. Concatenation with non-matching columns
df4 = pd.DataFrame({
    'A': ['A9', 'A10', 'A11'],
    'C': ['C9', 'C10', 'C11']
}, index=['K9', 'K10', 'K11'])

print("df4:")
print(df4)

# Outer join (keep all columns, fill with NaN)
result3 = pd.concat([df1, df4])
print("\n3a. Outer concatenation with non-matching columns:")
print(result3)

# Inner join (keep only shared columns)
result4 = pd.concat([df1, df4], join='inner')
print("\n3b. Inner concatenation (only shared columns):")
print(result4)

# 4. Concatenation with keys for multi-level indexing
result5 = pd.concat([df1, df2], keys=['df1', 'df2'])
print("\n4. Concatenation with keys (hierarchical index):")
print(result5)

# 5. Concatenation with new index
result6 = pd.concat([df1, df2], ignore_index=True)
print("\n5. Concatenation with new index:")
print(result6)
```

**Talking Points:**
- "Concatenation is like stacking datasets either vertically (axis=0) or horizontally (axis=1)."
- "Vertical concatenation is useful when you have data from different time periods in the same format."
- "Horizontal concatenation is useful when you have different features for the same observations."
- "The 'join' parameter determines how to handle columns that don't exist in all DataFrames."
- "The 'keys' parameter is powerful for keeping track of which rows came from which source."
- "Using 'ignore_index=True' is helpful when the original indices aren't meaningful after concatenation."

**Exercise 1: Basic Concatenation (1 minute)**

Have students execute:
```python
# Create datasets of quarterly sales for two years
sales_2022_Q1Q2 = pd.DataFrame({
    'Product': ['A', 'B', 'C'],
    'Q1_2022': [100, 200, 150],
    'Q2_2022': [120, 210, 170]
})

sales_2022_Q3Q4 = pd.DataFrame({
    'Product': ['A', 'B', 'C'],
    'Q3_2022': [130, 220, 160],
    'Q4_2022': [140, 230, 180]
})

sales_2023_Q1Q2 = pd.DataFrame({
    'Product': ['A', 'B', 'C', 'D'],  # Note: Added new product
    'Q1_2023': [145, 235, 185, 120],
    'Q2_2023': [150, 240, 190, 130]
})

print("2022 Q1-Q2:")
print(sales_2022_Q1Q2)
print("\n2022 Q3-Q4:")
print(sales_2022_Q3Q4)
print("\n2023 Q1-Q2:")
print(sales_2023_Q1Q2)

# Tasks:
# 1. Concatenate all 2022 data horizontally
sales_2022 = pd.concat([sales_2022_Q1Q2, sales_2022_Q3Q4], axis=1)
print("\n1. Complete 2022 sales data:")
print(sales_2022)

# 2. Concatenate 2022 and 2023 data vertically (keeping the product as the index)
all_sales = pd.concat([sales_2022.set_index('Product'), 
                      sales_2023_Q1Q2.set_index('Product')], 
                      axis=1)
print("\n2. All sales data by product:")
print(all_sales)
```

**Expected Learning Outcome:** Students should understand how to use pd.concat() to combine DataFrames both vertically and horizontally, and how to handle differences in columns and indices.

---

### 2. Database-Style Joins with merge() (5 minutes)

**Slide 3: Merging DataFrames**

| Parameter | Purpose | Common Values |
|-----------|---------|---------------|
| `left`, `right` | DataFrames to merge | DataFrame objects |
| `how` | Type of join | `'inner'` (default), `'outer'`, `'left'`, `'right'` |
| `on` | Column(s) to join on | Column name or list of names |
| `left_on`, `right_on` | Column(s) to join on when names differ | Column name(s) for each DataFrame |
| `left_index`, `right_index` | Use indices for joining | `False` (default), `True` |
| `suffixes` | Suffixes for duplicate columns | Tuple of strings, default `('_x', '_y')` |

**Code Example 3: Basic Merge Operations**
```python
# Create sample DataFrames for merging
employees = pd.DataFrame({
    'employee_id': [1, 2, 3, 4, 5],
    'name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],
    'department_id': [101, 102, 101, 103, 102]
})

departments = pd.DataFrame({
    'department_id': [101, 102, 103, 104],
    'department_name': ['HR', 'Engineering', 'Finance', 'Marketing'],
    'location': ['New York', 'San Francisco', 'Chicago', 'Boston']
})

print("Employees:")
print(employees)
print("\nDepartments:")
print(departments)

# 1. Inner join (default)
inner_merge = pd.merge(employees, departments, on='department_id')
print("\n1. Inner join (employees and departments):")
print(inner_merge)

# 2. Left join (keep all rows from left DataFrame)
left_merge = pd.merge(employees, departments, on='department_id', how='left')
print("\n2. Left join (keep all employees):")
print(left_merge)

# 3. Right join (keep all rows from right DataFrame)
right_merge = pd.merge(employees, departments, on='department_id', how='right')
print("\n3. Right join (keep all departments):")
print(right_merge)

# 4. Outer join (keep all rows from both DataFrames)
outer_merge = pd.merge(employees, departments, on='department_id', how='outer')
print("\n4. Outer join (keep everything):")
print(outer_merge)
```

**Code Example 4: Advanced Merge Operations**
```python
# Create DataFrames with different column names for the key
sales_data = pd.DataFrame({
    'product_id': [1, 2, 3, 4, 5],
    'units_sold': [100, 150, 200, 300, 250],
    'revenue': [1000, 1500, 2000, 3000, 2500]
})

product_data = pd.DataFrame({
    'id': [1, 2, 3, 6, 7],
    'name': ['Laptop', 'Phone', 'Tablet', 'Monitor', 'Keyboard'],
    'category': ['Electronics', 'Electronics', 'Electronics', 
                'Accessories', 'Accessories']
})

print("Sales Data:")
print(sales_data)
print("\nProduct Data:")
print(product_data)

# 1. Merge with different column names
merge_diff_cols = pd.merge(
    sales_data, 
    product_data, 
    left_on='product_id', 
    right_on='id'
)
print("\n1. Merge with different column names:")
print(merge_diff_cols)

# 2. Merge with multiple keys
# Create new DataFrames with composite keys
orders = pd.DataFrame({
    'order_id': [1001, 1002, 1003, 1004, 1005],
    'customer_id': [1, 2, 1, 3, 2],
    'product_id': [1, 2, 3, 2, 1],
    'quantity': [2, 1, 3, 2, 1]
})

inventory = pd.DataFrame({
    'product_id': [1, 2, 3, 4],
    'warehouse_id': [101, 102, 101, 103],
    'stock': [50, 30, 20, 10]
})

print("\nOrders:")
print(orders)
print("\nInventory:")
print(inventory)

# Merge on a single common column
order_inventory = pd.merge(
    orders, 
    inventory, 
    on='product_id'
)
print("\n2. Merge orders and inventory on product_id:")
print(order_inventory)

# 3. Merge on index
# Set indices for demonstration
employees.set_index('employee_id', inplace=True)
employee_details = pd.DataFrame({
    'salary': [65000, 72000, 58000, 85000, 62000],
    'hire_date': ['2020-01-15', '2019-05-20', '2021-03-10', 
                 '2018-11-05', '2020-08-22']
}, index=[1, 2, 3, 4, 6])  # Note: index 6 doesn't match

print("\nEmployees (indexed):")
print(employees)
print("\nEmployee Details:")
print(employee_details)

# Merge on index
merge_on_index = pd.merge(
    employees, 
    employee_details, 
    left_index=True, 
    right_index=True, 
    how='outer'
)
print("\n3. Merge on index (outer join):")
print(merge_on_index)
```

**Talking Points:**
- "The `merge()` function is modeled after SQL joins and is used to combine DataFrames based on common columns or indices."
- "The 'how' parameter determines which rows to keep: 'inner' (matching rows only), 'left' (all left rows), 'right' (all right rows), or 'outer' (all rows)."
- "When column names differ between DataFrames, use 'left_on' and 'right_on' to specify which columns to join on."
- "You can merge on multiple columns by passing lists to 'on', 'left_on', or 'right_on'."
- "When merging on indices instead of columns, use 'left_index=True' and/or 'right_index=True'."
- "Merging is a powerful way to enrich your dataset with additional information from other sources."

**Exercise 2: Merging DataFrames (1 minute)**

Have students execute:
```python
# Create DataFrames for customers and their orders
customers = pd.DataFrame({
    'customer_id': [101, 102, 103, 104, 105],
    'name': ['Alice', 'Bob', 'Charlie', 'Diana', 'Edward'],
    'country': ['USA', 'Canada', 'UK', 'USA', 'Australia']
})

orders = pd.DataFrame({
    'order_id': [1, 2, 3, 4, 5, 6],
    'customer_id': [101, 103, 102, 103, 106, 104],
    'amount': [150, 200, 300, 250, 175, 100],
    'date': ['2023-01-15', '2023-01-16', '2023-01-20', 
            '2023-02-01', '2023-02-02', '2023-02-05']
})

print("Customers:")
print(customers)
print("\nOrders:")
print(orders)

# Tasks:
# 1. Perform an inner join to get orders with customer information
customer_orders = pd.merge(orders, customers, on='customer_id')
print("\n1. Orders with customer information (inner join):")
print(customer_orders)

# 2. Use left join to keep all orders (even if customer not found)
all_orders = pd.merge(orders, customers, on='customer_id', how='left')
print("\n2. All orders with customer info where available (left join):")
print(all_orders)

# 3. Use right join to see which customers haven't placed orders
all_customers = pd.merge(orders, customers, on='customer_id', how='right')
print("\n3. All customers with their orders (right join):")
print(all_customers)
```

**Expected Learning Outcome:** Students should understand how to use pd.merge() to combine DataFrames based on common columns or indices, and how to choose the appropriate join type for their needs.

---

### 3. Handling Duplicate Columns and Indices (3 minutes)

**Slide 4: Managing Duplicates in Merging Operations**

| Problem | Solution | Method |
|---------|----------|--------|
| Duplicate columns after merge | Add suffixes | `suffixes=('_left', '_right')` |
| Keep only specific columns | Pre-select or post-select | `df[['col1', 'col2']]` |
| Duplicate index values | Reset or create unique index | `reset_index()` or use key |
| Duplicates in join key | Decide on handling strategy | Handle before merging |

**Code Example 5: Handling Duplicate Columns**
```python
# Create DataFrames with overlapping column names
df_a = pd.DataFrame({
    'key': ['K0', 'K1', 'K2'],
    'A': ['A0', 'A1', 'A2'],
    'B': ['B0', 'B1', 'B2']
})

df_b = pd.DataFrame({
    'key': ['K0', 'K2', 'K3'],
    'B': ['B3', 'B4', 'B5'],
    'C': ['C3', 'C4', 'C5']
})

print("DataFrame A:")
print(df_a)
print("\nDataFrame B:")
print(df_b)

# 1. Default behavior (adds _x and _y suffixes)
merged_default = pd.merge(df_a, df_b, on='key')
print("\n1. Default merge with overlapping columns:")
print(merged_default)

# 2. Custom suffixes
merged_custom = pd.merge(
    df_a, df_b, 
    on='key', 
    suffixes=('_left', '_right')
)
print("\n2. Merge with custom suffixes:")
print(merged_custom)

# 3. Pre-selecting columns to avoid duplication
merged_preselect = pd.merge(
    df_a[['key', 'A']], 
    df_b, 
    on='key'
)
print("\n3. Pre-selecting columns before merge:")
print(merged_preselect)

# 4. Post-selecting columns
merged_postselect = pd.merge(df_a, df_b, on='key')[['key', 'A', 'B_y', 'C']]
print("\n4. Post-selecting columns after merge:")
print(merged_postselect)
```

**Code Example 6: Handling Duplicate Indices**
```python
# Create DataFrames with duplicate indices
idx = ['K0', 'K1', 'K0', 'K2']  # Note the duplicate K0
values = [1, 2, 3, 4]

df_dupes = pd.DataFrame({'value': values}, index=idx)
print("DataFrame with duplicate indices:")
print(df_dupes)

# 1. Reset index to eliminate duplicates
df_reset = df_dupes.reset_index()
print("\n1. After resetting index:")
print(df_reset)

# 2. Create unique index with a key
df_reset['unique_key'] = ['K0_1', 'K1_1', 'K0_2', 'K2_1']
df_unique = df_reset.set_index('unique_key')
print("\n2. With unique index:")
print(df_unique)

# 3. Impact of duplicates on merging
df_c = pd.DataFrame({
    'key': ['K0', 'K1', 'K2'],
    'value': ['V0', 'V1', 'V2']
})

# Set the index to be the 'key' column
df_c = df_c.set_index('key')
print("\nDataFrame C (for joining):")
print(df_c)

# Join (similar to merge but uses indices)
# Note: Will join to both instances of K0
joined = df_dupes.join(df_c, how='left')
print("\n3. Joining with duplicate indices:")
print(joined)
```

**Talking Points:**
- "When merging DataFrames with duplicate column names, Pandas adds suffixes to make them unique."
- "You can customize these suffixes to make the result more readable."
- "Another approach is to select only the columns you need, either before or after merging."
- "Duplicate indices can cause unexpected behavior, especially with joins and lookups."
- "Be careful with duplicate values in join keys - each duplicate in one DataFrame will join with all matches in the other DataFrame, potentially creating many rows."
- "Always inspect the result after merging, especially checking the row count to ensure it matches expectations."

**Exercise 3: Handling Duplicates (1 minute)**

Have students execute:
```python
# Create DataFrames with duplicate column names
product_sales = pd.DataFrame({
    'product_id': [1, 2, 3, 4],
    'name': ['Laptop', 'Phone', 'Tablet', 'Monitor'],
    'price': [1200, 800, 350, 250],
    'category': ['Electronics', 'Electronics', 'Electronics', 'Electronics']
})

product_details = pd.DataFrame({
    'product_id': [1, 2, 3, 5],
    'name': ['Dell XPS 13', 'iPhone 13', 'iPad Pro', 'Logitech K380'],
    'weight_kg': [1.2, 0.17, 0.47, 0.42],
    'stock': [10, 25, 15, 30]
})

print("Product Sales:")
print(product_sales)
print("\nProduct Details:")
print(product_details)

# Tasks:
# 1. Merge with custom suffixes
merged = pd.merge(
    product_sales, 
    product_details, 
    on='product_id',
    suffixes=('_basic', '_full')
)
print("\n1. Merged with custom suffixes:")
print(merged)

# 2. Select only needed columns after merge
cleaned = merged[['product_id', 'name_full', 'price', 'category', 'weight_kg', 'stock']]
print("\n2. Cleaned up columns:")
print(cleaned)

# 3. Rename a column for clarity
final = cleaned.rename(columns={'name_full': 'full_name'})
print("\n3. Final clean dataset:")
print(final)
```

**Expected Learning Outcome:** Students should understand how to handle duplicate columns and indices when merging DataFrames, including using suffixes and selecting columns.

---

### Takeaway Message (1 minute)

**Slide 5: Key Takeaways for Merging DataFrames**

1. **Concatenation vs. Merging:** Choose concatenation for stacking similar data; use merging for combining related data on keys
2. **Join Types Matter:** Inner joins keep only matching data; outer joins keep everything; left/right joins are asymmetric
3. **Key Preparation:** Ensure join keys are clean and consistent before merging
4. **Handle Duplicates:** Be aware of how duplicate columns and indices affect merging operations
5. **Verify Results:** Always check the shape of the result to ensure merging worked as expected

**Closing Remarks:**
"The ability to combine data from different sources is a crucial skill in data analysis. Whether you're concatenating similar datasets or merging related tables, Pandas provides flexible tools for handling various scenarios. In the next session, we'll explore summary statistics and aggregations, which will allow us to derive insights from our now-combined datasets. Let's take a 5-minute break."
