# Introduction to Pandas (15 mins)
## Lecture Materials with Exercises

### Setting the Stage (2 minutes)

**Slide 1: What is Pandas?**
- A powerful Python library for data manipulation and analysis
- Built on top of NumPy (which you're already familiar with)
- Essential tool in data science, machine learning, and analytics
- Name comes from "panel data" - economic term for multidimensional data

**Talking Points:**
- "Pandas is to data analysis what NumPy is to numerical computing."
- "If you've ever used Excel or SQL, Pandas will feel somewhat familiar."
- "Today we'll see how the NumPy skills you've learned provide the foundation for Pandas."

---

### 1. Pandas vs NumPy Relationship (4 minutes)

**Slide 2: Key Differences**

| NumPy | Pandas |
|-------|--------|
| Homogeneous arrays | Heterogeneous data |
| Numerical focus | Tabular data focus |
| Unlabeled axes | Labeled axes |
| Fast mathematical operations | Data manipulation operations |
| Memory efficient | Feature rich |

**Code Example 1:**
```python
import numpy as np
import pandas as pd

# NumPy array - homogeneous data type
numpy_array = np.array([1, 2, 3, 4, 5])
print(f"NumPy array: {numpy_array}")
print(f"NumPy data type: {numpy_array.dtype}")

# Try to put mixed types in NumPy - notice what happens
mixed_numpy = np.array([1, 'string', 3.14])
print(f"Mixed NumPy array: {mixed_numpy}")
print(f"Mixed array dtype: {mixed_numpy.dtype}")  # Converts to common type

# Pandas Series - can handle mixed types
pandas_series = pd.Series([1, 'string', 3.14])
print("\nPandas Series with mixed types:")
print(pandas_series)
```

**Expected Output:**
```
NumPy array: [1 2 3 4 5]
NumPy data type: int64
Mixed NumPy array: ['1' 'string' '3.14']
Mixed array dtype: <U32

Pandas Series with mixed types:
0           1
1      string
2        3.14
dtype: object
```

**Talking Points:**
- "Notice how NumPy converts everything to strings when faced with mixed types?"
- "Pandas, on the other hand, preserves the original types using an 'object' dtype."
- "This flexibility is crucial when working with real-world data that rarely comes in neat, homogeneous packages."

**Exercise 1: NumPy vs Pandas Type Handling (2 minutes)**

Have students execute:
```python
# Create a NumPy array with dates and numbers
import datetime
numpy_dates = np.array([datetime.date(2023, 1, 1), 42, 3.14])
print("NumPy with dates and numbers:")
print(numpy_dates)
print(f"Resulting dtype: {numpy_dates.dtype}")

# Create a Pandas Series with the same data
pandas_dates = pd.Series([datetime.date(2023, 1, 1), 42, 3.14])
print("\nPandas Series with dates and numbers:")
print(pandas_dates)
print(f"Series dtypes: {pandas_dates.dtypes}")

# Try accessing the year from the date
try:
    print(f"\nNumPy - Year from first element: {numpy_dates[0].year}")
except AttributeError as e:
    print(f"NumPy error: {e}")
    
print(f"Pandas - Year from first element: {pandas_dates[0].year}")
```

**Expected Learning Outcome:** Students should observe that NumPy converts everything to strings or objects, losing the original type functionality, while Pandas preserves the original types and their behaviors.

---

### 2. Series and DataFrame Data Structures (5 minutes)

**Slide 3: The Pandas Series**
- 1D labeled array capable of holding any data type
- Like a cross between a list and a dictionary
- Has an Index (labels) and values (data)
- Built on NumPy, so supports vectorized operations

**Code Example 2:**
```python
# Creating a Series
s = pd.Series([10, 20, 30, 40], index=['a', 'b', 'c', 'd'])
print("Pandas Series with custom index:")
print(s)
print(f"The index: {s.index}")
print(f"The values: {s.values}")  # Notice this returns a NumPy array

# Dictionary-like access
print(f"\nValue at index 'b': {s['b']}")
print(f"Values at indices 'a' and 'c': {s[['a', 'c']]}")

# NumPy-like operations
print(f"\nAdding 5 to all values: \n{s + 5}")
print(f"Values greater than 25: \n{s > 25}")
```

**Slide 4: The Pandas DataFrame**
- 2D labeled data structure with columns of potentially different types
- Think: spreadsheet or SQL table
- Collection of Series objects that share the same index
- Primary data structure you'll use in data analysis

**Code Example 3:**
```python
# Creating a DataFrame
data = {
    'Name': ['Alice', 'Bob', 'Charlie'],
    'Age': [25, 30, 35],
    'City': ['New York', 'Boston', 'Chicago']
}
df = pd.DataFrame(data)
print("Pandas DataFrame:")
print(df)

# DataFrame info
print(f"\nDataFrame shape: {df.shape}")
print(f"DataFrame columns: {df.columns}")
print(f"DataFrame index: {df.index}")

# Accessing a column (returns a Series)
print("\nAccessing the Age column:")
print(df['Age'])
print(f"Type of column: {type(df['Age'])}")
```

**Talking Points:**
- "A Series is the building block in Pandas - think of it as a single column of data."
- "A DataFrame is a collection of Series objects sharing an index - like a table made up of columns."
- "The real power comes from being able to manipulate, filter, and analyze these structures easily."

**Exercise 2: Creating and Exploring DataFrames (2 minutes)**

Have students execute:
```python
# Create a DataFrame about programming languages
languages_data = {
    'Language': ['Python', 'R', 'Java'],
    'Year_Created': [1991, 1993, 1995],
    'Popular_For': ['General-purpose', 'Statistics', 'Enterprise']
}
lang_df = pd.DataFrame(languages_data)

# Explore the DataFrame
print("Programming Languages DataFrame:")
print(lang_df)

# Access a specific column
popular_for = lang_df['Popular_For']
print("\nPopular_For column (as a Series):")
print(popular_for)
print(f"Type: {type(popular_for)}")

# Try adding a new language
lang_df.loc[3] = ['JavaScript', 1995, 'Web Development']
print("\nUpdated DataFrame with JavaScript:")
print(lang_df)
```

**Expected Learning Outcome:** Students should understand that a DataFrame is made up of Series objects, and that both have labeled axes that make data access intuitive. They should also see how easy it is to add new data.

---

### 3. Creating Pandas Objects from NumPy Arrays (4 minutes)

**Slide 5: NumPy to Pandas Conversion**
- Pandas objects can be created directly from NumPy arrays
- Indexes can be automatically generated or custom-defined
- The underlying NumPy array is still accessible
- Pandas adds powerful indexing and data manipulation features

**Code Example 4:**
```python
# NumPy array to Pandas Series
numpy_data = np.array([100, 200, 300, 400])
s1 = pd.Series(numpy_data)
print("Series with default index:")
print(s1)

s2 = pd.Series(numpy_data, index=['w', 'x', 'y', 'z'])
print("\nSeries with custom index:")
print(s2)

# NumPy 2D array to DataFrame
array_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
df1 = pd.DataFrame(array_2d)
print("\nDataFrame from 2D array (default column names):")
print(df1)

df2 = pd.DataFrame(array_2d, 
                  columns=['A', 'B', 'C'],
                  index=['row1', 'row2', 'row3'])
print("\nDataFrame with custom row and column labels:")
print(df2)

# Converting back to NumPy
numpy_again = df2.to_numpy()
print("\nConverted back to NumPy:")
print(numpy_again)
```

**Talking Points:**
- "Your existing NumPy knowledge transfers directly to Pandas."
- "The key difference is the addition of labels, which makes data more self-describing."
- "Notice how Pandas automatically names axes when none are provided, but lets you customize when needed."
- "You can always convert back to NumPy when you need pure numerical performance."

**Exercise 3: NumPy to Pandas Conversion (2 minutes)**

Have students execute:
```python
# Create a 3x4 NumPy array of random integers
random_array = np.random.randint(1, 100, size=(3, 4))
print("Original NumPy array:")
print(random_array)

# Convert to DataFrame with custom labels
quarters_df = pd.DataFrame(
    random_array,
    columns=['Q1', 'Q2', 'Q3', 'Q4'],
    index=['Product A', 'Product B', 'Product C']
)
print("\nAs Pandas DataFrame with labels:")
print(quarters_df)

# Extract Q2 column as a Series
q2_series = quarters_df['Q2']
print("\nQ2 column as a Series:")
print(q2_series)
print(f"Series type: {type(q2_series)}")

# Demonstrate a calculation
print(f"\nAverage Q2 sales: {q2_series.mean():.2f}")
```

**Expected Learning Outcome:** Students should understand how to convert NumPy arrays to Pandas objects, add meaningful labels, extract portions of data, and perform calculations.

---

### Takeaway Message (1 minute)

**Slide 6: Key Takeaways**

1. **Building on NumPy:** Pandas uses NumPy under the hood, adding labels and mixed-type support
2. **Series:** 1D labeled array similar to a dictionary + array hybrid
3. **DataFrame:** 2D labeled structure, like a collection of Series sharing an index
4. **Labels Matter:** Named axes make your data self-documenting and easier to work with
5. **Data Types:** Pandas handles mixed types better than NumPy, crucial for real-world data

**Closing Remarks:**
"In the next session, we'll explore how to load and save data from various file formats, which is where you'll really start to see the power of Pandas in practice. The concepts we covered today - Series, DataFrames, and how they relate to NumPy - form the foundation for everything else we'll learn."
